package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"net/http"
	"os"
	"regexp"
	"strings"
	"unicode"
	"unicode/utf8"
)

const (
	contextPackage    = protogen.GoImportPath("context")
	httpClientPackage = protogen.GoImportPath("github.com/coolseven/http-client")
)

type methodDesc struct {
	Name         string
	Body         string
	Request      string
	Reply        string
	Path         string
	HasBody      bool
	Method       string
	ResponseBody string
}

func generateFile(gen *protogen.Plugin, f *protogen.File) *protogen.GeneratedFile {
	filename := f.GeneratedFilenamePrefix + "_client.pb.go"
	g := gen.NewGeneratedFile(filename, f.GoImportPath)
	g.P("// Code generated by protoc-gen-go-client. DO NOT EDIT")
	g.P("// version:")
	g.P(fmt.Sprintf("// protoc-gen-go-client %s", release))
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()
	genImports(gen, f, g)
	genContent(gen, f, g)
	return g
}

func genImports(gen *protogen.Plugin, f *protogen.File, g *protogen.GeneratedFile) {
	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		imp := imps.Get(i)
		impFile, ok := gen.FilesByPath[imp.Path()]
		if !ok {
			continue
		}
		if impFile.GoImportPath == f.GoImportPath {
			continue
		}

		if !imp.IsWeak {
			g.Import(impFile.GoImportPath)
		}
		if !imp.IsPublic {
			continue
		}

		impGen := generateFile(gen, impFile)
		impGen.Skip()
		b, err := impGen.Content()
		if err != nil {
			gen.Error(err)
			continue
		}
		fset := token.NewFileSet()
		astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
		if err != nil {
			gen.Error(err)
			return
		}
		genForward := func(tok token.Token, name string, expr ast.Expr) {
			// Don't import unexported symbols.
			r, _ := utf8.DecodeRuneInString(name)
			if !unicode.IsUpper(r) {
				return
			}
			// Don't import the FileDescriptor.
			if name == impFile.GoDescriptorIdent.GoName {
				return
			}
			// Don't import decls referencing a symbol defined in another package.
			// i.e., don't import decls which are themselves public imports:
			//
			//	type T = somepackage.T
			if _, ok := expr.(*ast.SelectorExpr); ok {
				return
			}
			g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
		}
		g.P("// Symbols defined in public import of ", imp.Path(), ".")
		g.P()
		for _, decl := range astFile.Decls {
			switch decl := decl.(type) {
			case *ast.GenDecl:
				for _, spec := range decl.Specs {
					switch spec := spec.(type) {
					case *ast.TypeSpec:
						genForward(decl.Tok, spec.Name.Name, spec.Type)
					case *ast.ValueSpec:
						for i, name := range spec.Names {
							var expr ast.Expr
							if i < len(spec.Values) {
								expr = spec.Values[i]
							}
							genForward(decl.Tok, name.Name, expr)
						}
					case *ast.ImportSpec:
					default:
						panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
					}
				}
			}
		}
		g.P()
	}
}

func genContent(gen *protogen.Plugin, f *protogen.File, g *protogen.GeneratedFile) {
	if len(f.Services) == 0 {
		return
	}

	g.P("var (")
	g.P("_ = new(", contextPackage.Ident("Context"), ")")
	g.P("_ = new(", httpClientPackage.Ident("Client"), ")")
	g.P(")")

	for _, s := range f.Services {
		genService(gen, f, g, s)
	}
}

func genService(gen *protogen.Plugin, f *protogen.File, g *protogen.GeneratedFile, s *protogen.Service) {
	methods := make([]*methodDesc, 0)

	for _, m := range s.Methods {
		if m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer() {
			return
		}
		rule, ok := proto.GetExtension(m.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)

		if rule != nil && ok {
			for _, bind := range rule.AdditionalBindings {
				methods = append(methods, buildHTTPRule(g, m, bind))
			}
			methods = append(methods, buildHTTPRule(g, m, rule))
		}
	}

	leadingComment := appendDeprecationSuffix(s.Comments.Leading, s.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated())
	// build interface
	g.P(leadingComment, "type ", s.GoName, "HTTPClient ", "interface {")
	for _, m := range methods {
		g.P(m.Name, "(ctx context.Context, req *", m.Request, ", opts ...http_client.CallRequestOption) (resp *", m.Reply, ", err error)")
	}
	g.P("}")
	g.P()

	// build struct
	g.P("type ", s.GoName, "HTTPClientImpl struct {")
	g.P("cc *http_client.Client")
	g.P("}")
	g.P()

	// build new method
	g.P("func New", s.GoName, "HTTPClient (client *http_client.Client) ", s.GoName, "HTTPClient {")
	g.P("return &", s.GoName, "HTTPClientImpl{client}")
	g.P("}")
	g.P()

	// build implement method
	for _, m := range methods {
		needQuery := "false"
		if !m.HasBody {
			needQuery = "true"
		}
		g.P("func (c *", s.GoName, "HTTPClientImpl) ", m.Name, "(ctx context.Context, in *", m.Request, ", opts ...http_client.CallRequestOption) (*", m.Reply, ", error) {")
		g.P("var out ", m.Reply)
		g.P("pattern := \"", m.Path, "\"")
		g.P("path := http_client.EncodeURL(pattern, in, ", needQuery, ")")
		if m.HasBody {
			g.P("err := c.cc.Request(ctx, \"", m.Method, "\", path, in, &out, opts...)")
		} else {
			g.P("err := c.cc.Request(ctx, \"", m.Method, "\", path, nil, &out, opts...)")
		}
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return &out, err")
		g.P("}")
		g.P()
	}
}

func buildHTTPRule(g *protogen.GeneratedFile, m *protogen.Method, rule *annotations.HttpRule) *methodDesc {
	var (
		path         string
		method       string
		body         string
		responseBody string
	)

	switch pattern := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		path = pattern.Get
		method = http.MethodGet
	case *annotations.HttpRule_Post:
		path = pattern.Post
		method = http.MethodPost
	case *annotations.HttpRule_Put:
		path = pattern.Put
		method = http.MethodPut
	case *annotations.HttpRule_Patch:
		path = pattern.Patch
		method = http.MethodPatch
	case *annotations.HttpRule_Delete:
		path = pattern.Delete
		method = http.MethodDelete
	case *annotations.HttpRule_Custom:
		path = pattern.Custom.Path
		method = strings.ToUpper(pattern.Custom.Kind)
	}
	body = rule.Body
	responseBody = rule.ResponseBody

	md := buildMethodDesc(g, m, method, path)
	if method == http.MethodGet || method == http.MethodDelete {
		if body != "" {
			_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: %s %s body should not be declared.\n", method, path)
		}
	} else {
		if body == "" {
			_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: %s %s body should not be declared.\n", method, path)
		}
	}
	if body == "*" {
		md.HasBody = true
		md.Body = ""
	} else if body != "" {
		md.HasBody = true
		md.Body = "." + camelCaseVars(body)
	} else {
		md.HasBody = false
	}

	if responseBody == "*" {
		md.ResponseBody = ""
	} else {
		md.ResponseBody = "." + camelCaseVars(responseBody)
	}

	return md
}

func buildMethodDesc(g *protogen.GeneratedFile, m *protogen.Method, method, path string) *methodDesc {
	vars := buildPathVars(path)
	fields := m.Input.Desc.Fields()

	for v, s := range vars {
		if s != nil {
			path = replacePath(v, *s, path)
		}
		for _, field := range strings.Split(v, ".") {
			if strings.TrimSpace(field) == "" {
				continue
			}
			if strings.Contains(field, ":") {
				field = strings.Split(field, ":")[0]
			}
			fd := fields.ByName(protoreflect.Name(field))
			if fd == nil {
				_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mERROR\u001B[m: The corresponding field '%s' declaration in message could not be found in '%s'\n", v, path)
				os.Exit(2)
			}
			if fd.IsMap() {
				_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: The field in path:'%s' shouldn't be a map.\n", v)
			} else if fd.IsList() {
				_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: The field in path:'%s' shouldn't be a list.\n", v)
			} else if fd.Kind() == protoreflect.MessageKind || fd.Kind() == protoreflect.GroupKind {
				fields = fd.Message().Fields()
			}
		}
	}

	return &methodDesc{
		Name:    m.GoName,
		Request: g.QualifiedGoIdent(m.Input.GoIdent),
		Reply:   g.QualifiedGoIdent(m.Output.GoIdent),
		Path:    path,
		Method:  method,
	}
}

func buildPathVars(path string) (res map[string]*string) {
	if strings.HasSuffix(path, "/") {
		_, _ = fmt.Fprintf(os.Stderr, "\u001B[31mWARN\u001B[m: Path %s should not end with \"/\" \n", path)
	}
	res = make(map[string]*string)
	pattern := regexp.MustCompile(`(?i){([a-z\.0-9_\s]*)=?([^{}]*)}`)
	matches := pattern.FindAllStringSubmatch(path, -1)
	for _, m := range matches {
		name := strings.TrimSpace(m[1])
		if len(name) > 1 && len(m[2]) > 0 {
			res[name] = &m[2]
		} else {
			res[name] = nil
		}
	}
	return
}

func appendDeprecationSuffix(prefix protogen.Comments, deprecated bool) protogen.Comments {
	if !deprecated {
		return prefix
	}
	if prefix != "" {
		prefix += "\n"
	}
	return prefix + " Deprecated: Do not use.\n"
}

func camelCaseVars(s string) string {
	subs := strings.Split(s, ".")
	vars := make([]string, 0, len(subs))
	for _, sub := range subs {
		vars = append(vars, camelCase(sub))
	}
	return strings.Join(vars, ".")
}

func camelCase(s string) string {
	if s == "" {
		return ""
	}
	t := make([]byte, 0, 32)
	i := 0
	if s[0] == '_' {
		// Need a capital letter; drop the '_'.
		t = append(t, 'X')
		i++
	}
	// Invariant: if the next letter is lower case, it must be converted
	// to upper case.
	// That is, we process a word at a time, where words are marked by _ or
	// upper case letter. Digits are treated as words.
	for ; i < len(s); i++ {
		c := s[i]
		if c == '_' && i+1 < len(s) && isASCIILower(s[i+1]) {
			continue // Skip the underscore in s.
		}
		if isASCIIDigit(c) {
			t = append(t, c)
			continue
		}
		// Assume we have a letter now - if not, it's a bogus identifier.
		// The next word is a sequence of characters that must start upper case.
		if isASCIILower(c) {
			c ^= ' ' // Make it a capital letter.
		}
		t = append(t, c) // Guaranteed not lower case.
		// Accept lower case sequence that follows.
		for i+1 < len(s) && isASCIILower(s[i+1]) {
			i++
			t = append(t, s[i])
		}
	}
	return string(t)
}

func isASCIILower(c byte) bool {
	return 'a' <= c && c <= 'z'
}

// Is c an ASCII digit?
func isASCIIDigit(c byte) bool {
	return '0' <= c && c <= '9'
}

func replacePath(name string, value string, path string) string {
	pattern := regexp.MustCompile(fmt.Sprintf(`(?i){([\s]*%s[\s]*)=?([^{}]*)}`, name))
	idx := pattern.FindStringIndex(path)
	if len(idx) > 0 {
		path = fmt.Sprintf("%s{%s:%s}%s",
			path[:idx[0]], // The start of the match
			name,
			strings.ReplaceAll(value, "*", ".*"),
			path[idx[1]:],
		)
	}
	return path
}
